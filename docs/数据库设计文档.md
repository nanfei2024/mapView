# 书籍知识图谱系统 - 数据库设计文档

## 数据库选型

### 推荐方案

**主数据库**: PostgreSQL 14+
- 成熟稳定的关系型数据库
- 支持 JSONB 类型存储灵活数据
- 强大的全文搜索功能
- 支持递归查询（CTE）

**图数据库（可选）**: Neo4j 5+
- 专门为图数据设计
- 高效的图遍历查询
- 可视化工具丰富
- 适合复杂关系查询

---

## PostgreSQL 数据库设计

### ER 图

```
┌──────────┐       ┌─────────────────┐       ┌──────────────────┐
│  books   │1────n│ knowledge_nodes │n────n│ knowledge_edges  │
└──────────┘       └─────────────────┘       └──────────────────┘
                            │
                            │1
                            │
                            │n
                   ┌────────────────┐
                   │ node_metadata  │
                   └────────────────┘
```

### 表结构设计

#### 1. books 表（书籍信息）

```sql
CREATE TABLE books (
    id VARCHAR(50) PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    author VARCHAR(100),
    cover_url VARCHAR(500),
    isbn VARCHAR(20) UNIQUE,
    publish_year INTEGER,
    publisher VARCHAR(100),
    description TEXT,
    tags TEXT[],
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP,
    
    CONSTRAINT chk_publish_year CHECK (publish_year >= 1000 AND publish_year <= 9999)
);

-- 索引
CREATE INDEX idx_books_name ON books USING gin(to_tsvector('chinese', name));
CREATE INDEX idx_books_author ON books(author);
CREATE INDEX idx_books_isbn ON books(isbn) WHERE isbn IS NOT NULL;
CREATE INDEX idx_books_tags ON books USING gin(tags);
CREATE INDEX idx_books_created_at ON books(created_at DESC);

-- 注释
COMMENT ON TABLE books IS '书籍信息表';
COMMENT ON COLUMN books.id IS '书籍唯一标识';
COMMENT ON COLUMN books.name IS '书籍名称';
COMMENT ON COLUMN books.metadata IS '扩展元数据（JSONB格式）';
```

**示例数据**:
```sql
INSERT INTO books (id, name, author, cover_url, publish_year, description, tags) VALUES
('book1', '板块构造与地貌形迹', '陈志明', '/images/板块构造与地貌形迹.jpg', 2020, 
 '详细阐述板块构造理论与地貌形成的关系', ARRAY['地质学', '板块构造', '地貌']);
```

#### 2. knowledge_nodes 表（知识节点）

```sql
CREATE TABLE knowledge_nodes (
    id VARCHAR(50) PRIMARY KEY,
    book_id VARCHAR(50) NOT NULL,
    parent_id VARCHAR(50),
    name VARCHAR(200) NOT NULL,
    category VARCHAR(50) NOT NULL,
    level INTEGER NOT NULL CHECK (level BETWEEN 1 AND 10),
    order_num INTEGER DEFAULT 0,
    symbol_size INTEGER DEFAULT 30,
    description TEXT,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP,
    
    FOREIGN KEY (book_id) REFERENCES books(id) ON DELETE CASCADE,
    FOREIGN KEY (parent_id) REFERENCES knowledge_nodes(id) ON DELETE CASCADE,
    
    CONSTRAINT chk_category CHECK (category IN (
        '书籍', '目录', '图表', '引文', '章节', '图片', '表格', '引用'
    ))
);

-- 索引
CREATE INDEX idx_nodes_book_id ON knowledge_nodes(book_id);
CREATE INDEX idx_nodes_parent_id ON knowledge_nodes(parent_id);
CREATE INDEX idx_nodes_category ON knowledge_nodes(category);
CREATE INDEX idx_nodes_level ON knowledge_nodes(level);
CREATE INDEX idx_nodes_name ON knowledge_nodes USING gin(to_tsvector('chinese', name));
CREATE INDEX idx_nodes_order ON knowledge_nodes(book_id, parent_id, order_num);

-- 注释
COMMENT ON TABLE knowledge_nodes IS '知识节点表';
COMMENT ON COLUMN knowledge_nodes.category IS '节点类型：书籍/目录/图表/引文/章节/图片/表格/引用';
COMMENT ON COLUMN knowledge_nodes.level IS '节点层级：1-书籍，2-分类，3-具体内容';
COMMENT ON COLUMN knowledge_nodes.order_num IS '同级节点排序序号';
```

**示例数据**:
```sql
INSERT INTO knowledge_nodes (id, book_id, parent_id, name, category, level, order_num) VALUES
('book1', 'book1', NULL, '板块构造与地貌形迹', '书籍', 1, 0),
('book1_catalog', 'book1', 'book1', '目录', '目录', 2, 1),
('book1_catalog_1', 'book1', 'book1_catalog', '第一章：劳亚区系', '章节', 3, 1);
```

#### 3. knowledge_edges 表（知识关系）

```sql
CREATE TABLE knowledge_edges (
    id VARCHAR(50) PRIMARY KEY,
    source_id VARCHAR(50) NOT NULL,
    target_id VARCHAR(50) NOT NULL,
    relation_type VARCHAR(50) NOT NULL DEFAULT 'contains',
    weight DECIMAL(3,2) DEFAULT 1.0 CHECK (weight BETWEEN 0 AND 1),
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (source_id) REFERENCES knowledge_nodes(id) ON DELETE CASCADE,
    FOREIGN KEY (target_id) REFERENCES knowledge_nodes(id) ON DELETE CASCADE,
    
    CONSTRAINT chk_relation_type CHECK (relation_type IN (
        'contains', 'references', 'relates', 'derives', 'cites'
    )),
    CONSTRAINT chk_no_self_loop CHECK (source_id != target_id),
    CONSTRAINT uk_edge UNIQUE (source_id, target_id, relation_type)
);

-- 索引
CREATE INDEX idx_edges_source ON knowledge_edges(source_id);
CREATE INDEX idx_edges_target ON knowledge_edges(target_id);
CREATE INDEX idx_edges_relation ON knowledge_edges(relation_type);

-- 注释
COMMENT ON TABLE knowledge_edges IS '知识节点关系表';
COMMENT ON COLUMN knowledge_edges.relation_type IS '关系类型：contains包含/references引用/relates相关/derives派生/cites引用';
COMMENT ON COLUMN knowledge_edges.weight IS '关系权重（0-1）';
```

#### 4. qa_conversations 表（问答记录）

```sql
CREATE TABLE qa_conversations (
    id VARCHAR(50) PRIMARY KEY,
    book_id VARCHAR(50),
    question TEXT NOT NULL,
    answer TEXT NOT NULL,
    related_nodes JSONB DEFAULT '[]',
    use_ai BOOLEAN DEFAULT FALSE,
    ai_model VARCHAR(50),
    confidence DECIMAL(3,2),
    response_time INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (book_id) REFERENCES books(id) ON DELETE SET NULL
);

-- 索引
CREATE INDEX idx_qa_book_id ON qa_conversations(book_id);
CREATE INDEX idx_qa_created_at ON qa_conversations(created_at DESC);
CREATE INDEX idx_qa_question ON qa_conversations USING gin(to_tsvector('chinese', question));

-- 注释
COMMENT ON TABLE qa_conversations IS '问答对话记录表';
COMMENT ON COLUMN qa_conversations.confidence IS '回答置信度（0-1）';
COMMENT ON COLUMN qa_conversations.response_time IS '响应时间（毫秒）';
```

#### 5. graph_versions 表（图谱版本）

```sql
CREATE TABLE graph_versions (
    id SERIAL PRIMARY KEY,
    book_id VARCHAR(50) NOT NULL,
    version VARCHAR(20) NOT NULL,
    description TEXT,
    graph_data JSONB NOT NULL,
    created_by VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (book_id) REFERENCES books(id) ON DELETE CASCADE,
    CONSTRAINT uk_book_version UNIQUE (book_id, version)
);

-- 索引
CREATE INDEX idx_versions_book_id ON graph_versions(book_id);
CREATE INDEX idx_versions_created_at ON graph_versions(created_at DESC);

-- 注释
COMMENT ON TABLE graph_versions IS '知识图谱版本历史表';
```

#### 6. user_activities 表（用户活动日志）

```sql
CREATE TABLE user_activities (
    id BIGSERIAL PRIMARY KEY,
    user_id VARCHAR(50),
    activity_type VARCHAR(50) NOT NULL,
    resource_type VARCHAR(50),
    resource_id VARCHAR(50),
    details JSONB DEFAULT '{}',
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT chk_activity_type CHECK (activity_type IN (
        'view', 'create', 'update', 'delete', 'search', 'export', 'import'
    ))
);

-- 索引
CREATE INDEX idx_activities_user_id ON user_activities(user_id);
CREATE INDEX idx_activities_type ON user_activities(activity_type);
CREATE INDEX idx_activities_created_at ON user_activities(created_at DESC);
CREATE INDEX idx_activities_resource ON user_activities(resource_type, resource_id);
```

---

### 视图设计

#### 1. v_book_statistics（书籍统计视图）

```sql
CREATE OR REPLACE VIEW v_book_statistics AS
SELECT 
    b.id AS book_id,
    b.name AS book_name,
    COUNT(DISTINCT n.id) AS total_nodes,
    COUNT(DISTINCT CASE WHEN n.category = '章节' THEN n.id END) AS chapter_count,
    COUNT(DISTINCT CASE WHEN n.category IN ('图片', '表格') THEN n.id END) AS figure_count,
    COUNT(DISTINCT CASE WHEN n.category = '引用' THEN n.id END) AS citation_count,
    MAX(n.level) AS max_depth,
    b.created_at,
    b.updated_at
FROM books b
LEFT JOIN knowledge_nodes n ON b.id = n.book_id AND n.deleted_at IS NULL
WHERE b.deleted_at IS NULL
GROUP BY b.id, b.name, b.created_at, b.updated_at;
```

#### 2. v_node_hierarchy（节点层级视图）

```sql
CREATE OR REPLACE VIEW v_node_hierarchy AS
WITH RECURSIVE node_path AS (
    -- 根节点
    SELECT 
        id,
        book_id,
        parent_id,
        name,
        category,
        level,
        ARRAY[name] AS path,
        ARRAY[id] AS id_path,
        1 AS depth
    FROM knowledge_nodes
    WHERE parent_id IS NULL AND deleted_at IS NULL
    
    UNION ALL
    
    -- 递归查询子节点
    SELECT 
        n.id,
        n.book_id,
        n.parent_id,
        n.name,
        n.category,
        n.level,
        np.path || n.name,
        np.id_path || n.id,
        np.depth + 1
    FROM knowledge_nodes n
    INNER JOIN node_path np ON n.parent_id = np.id
    WHERE n.deleted_at IS NULL
)
SELECT * FROM node_path;
```

---

### 存储过程

#### 1. 获取节点的所有子节点

```sql
CREATE OR REPLACE FUNCTION get_node_descendants(node_id VARCHAR)
RETURNS TABLE (
    id VARCHAR,
    name VARCHAR,
    category VARCHAR,
    level INTEGER,
    depth INTEGER
) AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE descendants AS (
        SELECT 
            n.id,
            n.name,
            n.category,
            n.level,
            1 AS depth
        FROM knowledge_nodes n
        WHERE n.id = node_id AND n.deleted_at IS NULL
        
        UNION ALL
        
        SELECT 
            n.id,
            n.name,
            n.category,
            n.level,
            d.depth + 1
        FROM knowledge_nodes n
        INNER JOIN descendants d ON n.parent_id = d.id
        WHERE n.deleted_at IS NULL
    )
    SELECT * FROM descendants;
END;
$$ LANGUAGE plpgsql;
```

#### 2. 删除节点及其子节点

```sql
CREATE OR REPLACE FUNCTION delete_node_cascade(node_id VARCHAR)
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    WITH RECURSIVE descendants AS (
        SELECT id FROM knowledge_nodes WHERE id = node_id
        UNION ALL
        SELECT n.id 
        FROM knowledge_nodes n
        INNER JOIN descendants d ON n.parent_id = d.id
    )
    UPDATE knowledge_nodes
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE id IN (SELECT id FROM descendants)
    AND deleted_at IS NULL;
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;
```

---

### 触发器

#### 1. 自动更新 updated_at

```sql
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_books_updated_at
    BEFORE UPDATE ON books
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trigger_nodes_updated_at
    BEFORE UPDATE ON knowledge_nodes
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

#### 2. 自动创建边关系

```sql
CREATE OR REPLACE FUNCTION auto_create_edge()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.parent_id IS NOT NULL THEN
        INSERT INTO knowledge_edges (id, source_id, target_id, relation_type)
        VALUES (
            NEW.id || '_edge',
            NEW.parent_id,
            NEW.id,
            'contains'
        )
        ON CONFLICT DO NOTHING;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_auto_create_edge
    AFTER INSERT ON knowledge_nodes
    FOR EACH ROW
    EXECUTE FUNCTION auto_create_edge();
```

---

## Neo4j 图数据库设计（可选）

### 节点类型

```cypher
// 书籍节点
(:Book {
    id: String,
    name: String,
    author: String,
    coverUrl: String,
    publishYear: Integer
})

// 知识节点
(:KnowledgeNode {
    id: String,
    name: String,
    category: String,
    level: Integer,
    description: String
})
```

### 关系类型

```cypher
// 包含关系
(:Book)-[:CONTAINS]->(:KnowledgeNode)
(:KnowledgeNode)-[:CONTAINS]->(:KnowledgeNode)

// 引用关系
(:KnowledgeNode)-[:REFERENCES]->(:KnowledgeNode)

// 相关关系
(:KnowledgeNode)-[:RELATES_TO]->(:KnowledgeNode)
```

### 示例查询

#### 1. 创建书籍和知识图谱

```cypher
// 创建书籍
CREATE (b:Book {
    id: 'book1',
    name: '板块构造与地貌形迹',
    author: '陈志明',
    coverUrl: '/images/板块构造与地貌形迹.jpg',
    publishYear: 2020
})

// 创建目录节点
CREATE (c:KnowledgeNode {
    id: 'book1_catalog',
    name: '目录',
    category: '目录',
    level: 2
})

// 创建章节节点
CREATE (ch:KnowledgeNode {
    id: 'book1_catalog_1',
    name: '第一章：劳亚区系',
    category: '章节',
    level: 3
})

// 创建关系
CREATE (b)-[:CONTAINS]->(c)
CREATE (c)-[:CONTAINS]->(ch)
```

#### 2. 查询书籍的完整知识图谱

```cypher
MATCH path = (b:Book {id: 'book1'})-[:CONTAINS*]->(n:KnowledgeNode)
RETURN path
```

#### 3. 查询特定深度的节点

```cypher
MATCH (b:Book {id: 'book1'})-[:CONTAINS*1..2]->(n:KnowledgeNode)
RETURN n.name, n.category, n.level
```

#### 4. 查找相关节点

```cypher
MATCH (n1:KnowledgeNode {id: 'book1_catalog_1'})-[:RELATES_TO]-(n2:KnowledgeNode)
RETURN n2.name, n2.category
```

---

## 数据迁移脚本

### PostgreSQL 初始化脚本

```sql
-- init.sql

-- 创建数据库
CREATE DATABASE knowledge_graph
    WITH 
    ENCODING = 'UTF8'
    LC_COLLATE = 'zh_CN.UTF-8'
    LC_CTYPE = 'zh_CN.UTF-8'
    TEMPLATE = template0;

\c knowledge_graph

-- 启用扩展
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";

-- 创建表（按上面的定义）
-- ...

-- 插入初始数据
INSERT INTO books (id, name, author, cover_url, publish_year, description, tags) VALUES
('book1', '板块构造与地貌形迹', '陈志明', '/images/板块构造与地貌形迹.jpg', 2020, 
 '详细阐述板块构造理论与地貌形成的关系', ARRAY['地质学', '板块构造']),
('book2', '亚洲地貌圈及其板块造貌构造纲要', '李明', '/images/亚洲地貌圈及其板块造貌构造纲要.jpg', 2019,
 '研究亚洲地貌圈的板块构造特征', ARRAY['地质学', '亚洲地貌']),
('book3', '地学新两论', '王强', '/images/地学新两论 上篇 板块造貌构造学-兼论板块学说新发展.jpg', 2021,
 '探讨板块造貌构造学的新发展', ARRAY['地质学', '板块学说']);
```

---

## 性能优化建议

### 1. 索引优化

- 为常用查询字段创建索引
- 使用复合索引优化多字段查询
- 定期分析和重建索引

```sql
-- 分析表
ANALYZE books;
ANALYZE knowledge_nodes;

-- 重建索引
REINDEX TABLE knowledge_nodes;
```

### 2. 查询优化

- 使用 EXPLAIN ANALYZE 分析查询计划
- 避免 N+1 查询问题
- 使用 CTE 优化递归查询

```sql
-- 查看查询计划
EXPLAIN ANALYZE
SELECT * FROM knowledge_nodes WHERE book_id = 'book1';
```

### 3. 分区表（大数据量时）

```sql
-- 按书籍ID分区
CREATE TABLE knowledge_nodes_partitioned (
    LIKE knowledge_nodes INCLUDING ALL
) PARTITION BY LIST (book_id);

CREATE TABLE knowledge_nodes_book1 PARTITION OF knowledge_nodes_partitioned
    FOR VALUES IN ('book1');
```

---

## 备份与恢复

### 备份

```bash
# 备份整个数据库
pg_dump -U postgres knowledge_graph > backup.sql

# 备份特定表
pg_dump -U postgres -t books -t knowledge_nodes knowledge_graph > tables_backup.sql
```

### 恢复

```bash
# 恢复数据库
psql -U postgres knowledge_graph < backup.sql
```

---

## 数据字典

完整的数据字典请参考各表的注释和约束定义。

---

## 版本历史

- v1.0.0 (2024-01-01): 初始数据库设计
- v1.1.0 (2024-02-01): 添加问答记录表
- v1.2.0 (2024-03-01): 添加版本管理表
