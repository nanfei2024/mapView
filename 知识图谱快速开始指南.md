# ğŸš€ çŸ¥è¯†å›¾è°±å¿«é€Ÿå¼€å§‹æŒ‡å—

## ğŸ“‹ æ¦‚è¿°

æœ¬æŒ‡å—å¸®åŠ©æ‚¨å¿«é€Ÿåœ¨ç°æœ‰å›¾ä¹¦è§£æç³»ç»Ÿä¸­é›†æˆçŸ¥è¯†å›¾è°±åŠŸèƒ½ã€‚å»ºè®®å…ˆé˜…è¯»ã€ŠçŸ¥è¯†å›¾è°±é›†æˆæ–¹æ¡ˆ.mdã€‹äº†è§£å®Œæ•´æ¶æ„ã€‚

---

## ğŸ¯ æœ€å°å¯è¡Œæ–¹æ¡ˆï¼ˆMVPï¼‰

### ç¬¬ä¸€æ­¥ï¼šæ•°æ®åº“å‡†å¤‡

#### æ–¹æ¡ˆAï¼šä½¿ç”¨MySQLï¼ˆæ¨èï¼Œæ— éœ€é¢å¤–éƒ¨ç½²ï¼‰

```sql
-- 1. åˆ›å»ºå®ä½“è¡¨
CREATE TABLE kg_entities (
    id VARCHAR(50) PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    type VARCHAR(50) NOT NULL,
    description TEXT,
    source_document_id VARCHAR(50),
    source_chapter VARCHAR(100),
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_name (name),
    INDEX idx_type (type),
    INDEX idx_document (source_document_id)
);

-- 2. åˆ›å»ºå…³ç³»è¡¨
CREATE TABLE kg_relations (
    id VARCHAR(50) PRIMARY KEY,
    source_entity_id VARCHAR(50) NOT NULL,
    target_entity_id VARCHAR(50) NOT NULL,
    relation_type VARCHAR(50) NOT NULL,
    source_text TEXT,
    source_document_id VARCHAR(50),
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (source_entity_id) REFERENCES kg_entities(id),
    FOREIGN KEY (target_entity_id) REFERENCES kg_entities(id),
    INDEX idx_source (source_entity_id),
    INDEX idx_target (target_entity_id)
);
```

#### æ–¹æ¡ˆBï¼šä½¿ç”¨Neo4jï¼ˆé€‚åˆå¤§è§„æ¨¡å›¾è°±ï¼‰

```bash
# å®‰è£…Neo4j
docker run -d \
  --name neo4j \
  -p 7474:7474 -p 7687:7687 \
  -e NEO4J_AUTH=neo4j/password \
  neo4j:latest
```

---

### ç¬¬äºŒæ­¥ï¼šå‰ç«¯APIå°è£…

åˆ›å»º `src/api/knowledgeGraphApi.ts`ï¼š

```typescript
const BASE_URL = 'http://localhost:8080';

export interface Entity {
  id: string;
  name: string;
  type: string;
  description?: string;
  sourceDocumentId?: string;
  sourceChapter?: string;
}

export interface Relation {
  id: string;
  sourceEntityId: string;
  targetEntityId: string;
  type: string;
  sourceText?: string;
}

export interface KnowledgeGraph {
  entities: Entity[];
  relations: Relation[];
}

export const knowledgeGraphApi = {
  // ä»æ–‡æ¡£æå–çŸ¥è¯†å›¾è°±
  async extractFromDocument(documentId: string): Promise<KnowledgeGraph> {
    const response = await fetch(`${BASE_URL}/api/knowledge-graph/extract`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ documentId })
    });
    return response.json();
  },

  // è·å–æ–‡æ¡£çš„çŸ¥è¯†å›¾è°±
  async getGraph(documentId: string): Promise<KnowledgeGraph> {
    const response = await fetch(`${BASE_URL}/api/knowledge-graph/${documentId}`);
    return response.json();
  },

  // æœç´¢å®ä½“
  async searchEntities(query: string): Promise<Entity[]> {
    const response = await fetch(
      `${BASE_URL}/api/knowledge-graph/entities/search?q=${encodeURIComponent(query)}`
    );
    return response.json();
  },

  // è·å–å®ä½“è¯¦æƒ…
  async getEntity(entityId: string): Promise<Entity> {
    const response = await fetch(`${BASE_URL}/api/knowledge-graph/entities/${entityId}`);
    return response.json();
  }
};
```

---

### ç¬¬ä¸‰æ­¥ï¼šç®€å•çš„å®ä½“æå–

åœ¨ `BookViewer.vue` ä¸­æ·»åŠ æå–åŠŸèƒ½ï¼š

```typescript
// åœ¨ BookViewer.vue çš„ script éƒ¨åˆ†æ·»åŠ 

import { knowledgeGraphApi } from '@/api/knowledgeGraphApi';

// ä»ç›®å½•æå–å®ä½“
function extractEntitiesFromToc(toc: TocItem[]): Entity[] {
  const entities: Entity[] = [];
  
  function traverse(items: TocItem[], parentChapter?: string) {
    items.forEach(item => {
      // æå–ç« èŠ‚æ ‡é¢˜ä¸­çš„åœ°è´¨æœ¯è¯­
      const terms = extractGeologicalTerms(item.title);
      
      terms.forEach(term => {
        entities.push({
          id: `entity_${Date.now()}_${Math.random()}`,
          name: term,
          type: detectEntityType(term),
          sourceChapter: item.title,
          sourceDocumentId: props.book?.id
        });
      });
      
      if (item.children) {
        traverse(item.children, item.title);
      }
    });
  }
  
  traverse(toc);
  return entities;
}

// ç®€å•çš„åœ°è´¨æœ¯è¯­æå–
function extractGeologicalTerms(text: string): string[] {
  const patterns = [
    /([\u4e00-\u9fa5]+åŒºç³»)/g,
    /([\u4e00-\u9fa5]+æ¿å—)/g,
    /([\u4e00-\u9fa5]+å¸¦)/g,
    /([\u4e00-\u9fa5]+è¿åŠ¨)/g,
    /([\u4e00-\u9fa5]+æ„é€ )/g
  ];
  
  const terms: string[] = [];
  patterns.forEach(pattern => {
    const matches = text.match(pattern);
    if (matches) terms.push(...matches);
  });
  
  return [...new Set(terms)];
}

// æ ¹æ®æœ¯è¯­åˆ¤æ–­å®ä½“ç±»å‹
function detectEntityType(term: string): string {
  if (term.includes('åŒºç³»') || term.includes('æ¿å—')) {
    return 'geological_structure';
  }
  if (term.includes('å¸¦') || term.includes('åŒºåŸŸ')) {
    return 'location';
  }
  if (term.includes('è¿åŠ¨') || term.includes('æ´»åŠ¨')) {
    return 'geological_phenomenon';
  }
  return 'concept';
}

// åœ¨ç›®å½•ç»†åŒ–å®Œæˆåè°ƒç”¨
async function onTocGenerated(toc: TocItem[]) {
  const entities = extractEntitiesFromToc(toc);
  
  // ä¿å­˜åˆ°åç«¯
  if (entities.length > 0) {
    try {
      await knowledgeGraphApi.extractFromDocument(props.book?.id || '');
      console.log('âœ… çŸ¥è¯†å›¾è°±æå–å®Œæˆï¼Œå…±æå–', entities.length, 'ä¸ªå®ä½“');
    } catch (error) {
      console.error('âŒ çŸ¥è¯†å›¾è°±æå–å¤±è´¥:', error);
    }
  }
}
```

---

### ç¬¬å››æ­¥ï¼šç®€å•çš„å¯è§†åŒ–ç»„ä»¶

åˆ›å»º `src/components/KnowledgeGraphViewer.vue`ï¼š

```vue
<template>
  <div class="knowledge-graph-viewer">
    <div class="graph-header">
      <h3>çŸ¥è¯†å›¾è°±</h3>
      <button @click="loadGraph">åˆ·æ–°</button>
    </div>
    
    <div ref="graphContainer" class="graph-container"></div>
    
    <div v-if="selectedEntity" class="entity-panel">
      <h4>{{ selectedEntity.name }}</h4>
      <p>ç±»å‹: {{ selectedEntity.type }}</p>
      <p v-if="selectedEntity.description">{{ selectedEntity.description }}</p>
      <p>æ¥æº: {{ selectedEntity.sourceChapter }}</p>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import { knowledgeGraphApi, type KnowledgeGraph, type Entity } from '@/api/knowledgeGraphApi';

const props = defineProps<{
  documentId: string;
}>();

const graphContainer = ref<HTMLElement>();
const selectedEntity = ref<Entity | null>(null);
const graph = ref<KnowledgeGraph | null>(null);

const loadGraph = async () => {
  graph.value = await knowledgeGraphApi.getGraph(props.documentId);
  renderGraph();
};

const renderGraph = () => {
  if (!graph.value || !graphContainer.value) return;
  
  // ç®€å•çš„æ–‡æœ¬å¯è§†åŒ–ï¼ˆåç»­å¯å‡çº§ä¸ºå›¾å½¢å¯è§†åŒ–ï¼‰
  const container = graphContainer.value;
  container.innerHTML = '';
  
  // æ˜¾ç¤ºå®ä½“åˆ—è¡¨
  const entityList = document.createElement('div');
  entityList.className = 'entity-list';
  
  graph.value.entities.forEach(entity => {
    const item = document.createElement('div');
    item.className = 'entity-item';
    item.textContent = entity.name;
    item.onclick = () => {
      selectedEntity.value = entity;
    };
    entityList.appendChild(item);
  });
  
  container.appendChild(entityList);
  
  // æ˜¾ç¤ºå…³ç³»åˆ—è¡¨
  const relationList = document.createElement('div');
  relationList.className = 'relation-list';
  relationList.innerHTML = '<h4>å…³ç³»</h4>';
  
  graph.value.relations.forEach(relation => {
    const source = graph.value!.entities.find(e => e.id === relation.sourceEntityId);
    const target = graph.value!.entities.find(e => e.id === relation.targetEntityId);
    
    if (source && target) {
      const item = document.createElement('div');
      item.className = 'relation-item';
      item.textContent = `${source.name} --[${relation.type}]--> ${target.name}`;
      relationList.appendChild(item);
    }
  });
  
  container.appendChild(relationList);
};

onMounted(() => {
  loadGraph();
});
</script>

<style scoped>
.knowledge-graph-viewer {
  padding: 20px;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  background: white;
}

.graph-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.graph-container {
  min-height: 400px;
  max-height: 600px;
  overflow-y: auto;
}

.entity-list {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 20px;
}

.entity-item {
  padding: 8px 16px;
  background: #f3f4f6;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s;
}

.entity-item:hover {
  background: #3b82f6;
  color: white;
}

.relation-list {
  margin-top: 20px;
  padding-top: 20px;
  border-top: 1px solid #e5e7eb;
}

.relation-item {
  padding: 8px;
  margin: 4px 0;
  background: #f9fafb;
  border-radius: 4px;
  font-family: monospace;
  font-size: 14px;
}

.entity-panel {
  margin-top: 20px;
  padding: 16px;
  background: #eff6ff;
  border-radius: 8px;
  border-left: 4px solid #3b82f6;
}
</style>
```

---

### ç¬¬äº”æ­¥ï¼šé›†æˆåˆ°BookViewer

åœ¨ `BookViewer.vue` ä¸­æ·»åŠ çŸ¥è¯†å›¾è°±æ ‡ç­¾é¡µï¼š

```vue
<!-- åœ¨ BookViewer.vue çš„ template ä¸­æ·»åŠ  -->
<el-tabs v-model="activeTab">
  <!-- ç°æœ‰çš„æ ‡ç­¾é¡µ -->
  <el-tab-pane label="ç›®å½•" name="toc">...</el-tab-pane>
  <el-tab-pane label="å†…å®¹" name="content">...</el-tab-pane>
  
  <!-- æ–°å¢ï¼šçŸ¥è¯†å›¾è°±æ ‡ç­¾é¡µ -->
  <el-tab-pane label="çŸ¥è¯†å›¾è°±" name="knowledge-graph">
    <KnowledgeGraphViewer :document-id="book.id" />
  </el-tab-pane>
</el-tabs>
```

```typescript
// åœ¨ script ä¸­æ·»åŠ 
import KnowledgeGraphViewer from './KnowledgeGraphViewer.vue';
```

---

## ğŸ”§ åç«¯å®ç°ï¼ˆNode.jsç¤ºä¾‹ï¼‰

### åŸºç¡€APIå®ç°

```javascript
// routes/knowledgeGraph.js

const express = require('express');
const router = express.Router();
const db = require('../db'); // æ•°æ®åº“è¿æ¥

// ä»æ–‡æ¡£æå–çŸ¥è¯†å›¾è°±
router.post('/extract', async (req, res) => {
  const { documentId } = req.body;
  
  try {
    // 1. è·å–æ–‡æ¡£çš„ç›®å½•å’Œå†…å®¹
    const document = await getDocument(documentId);
    const toc = await getToc(documentId);
    const content = await getMarkdownContent(documentId);
    
    // 2. æå–å®ä½“ï¼ˆç®€åŒ–ç‰ˆï¼‰
    const entities = extractEntitiesFromToc(toc);
    
    // 3. æå–å…³ç³»ï¼ˆç®€åŒ–ç‰ˆï¼‰
    const relations = extractRelations(content, entities);
    
    // 4. ä¿å­˜åˆ°æ•°æ®åº“
    for (const entity of entities) {
      await db.query(
        'INSERT INTO kg_entities (id, name, type, source_document_id, source_chapter) VALUES (?, ?, ?, ?, ?)',
        [entity.id, entity.name, entity.type, documentId, entity.sourceChapter]
      );
    }
    
    for (const relation of relations) {
      await db.query(
        'INSERT INTO kg_relations (id, source_entity_id, target_entity_id, relation_type, source_document_id) VALUES (?, ?, ?, ?, ?)',
        [relation.id, relation.sourceEntityId, relation.targetEntityId, relation.type, documentId]
      );
    }
    
    res.json({
      success: true,
      data: {
        entityCount: entities.length,
        relationCount: relations.length
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// è·å–æ–‡æ¡£çš„çŸ¥è¯†å›¾è°±
router.get('/:documentId', async (req, res) => {
  const { documentId } = req.params;
  
  try {
    const entities = await db.query(
      'SELECT * FROM kg_entities WHERE source_document_id = ?',
      [documentId]
    );
    
    const relations = await db.query(
      'SELECT * FROM kg_relations WHERE source_document_id = ?',
      [documentId]
    );
    
    res.json({
      success: true,
      data: { entities, relations }
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// æœç´¢å®ä½“
router.get('/entities/search', async (req, res) => {
  const { q } = req.query;
  
  try {
    const entities = await db.query(
      'SELECT * FROM kg_entities WHERE name LIKE ? LIMIT 20',
      [`%${q}%`]
    );
    
    res.json({ success: true, data: entities });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

module.exports = router;
```

---

## ğŸ“ˆ åç»­ä¼˜åŒ–æ–¹å‘

### 1. å‡çº§å¯è§†åŒ–

ä½¿ç”¨ D3.js æˆ– vis-network å®ç°å›¾å½¢åŒ–å›¾è°±ï¼š

```bash
npm install vis-network
```

```vue
<script setup>
import { Network } from 'vis-network';

// ä½¿ç”¨ vis-network æ¸²æŸ“å›¾è°±
const renderGraphWithVis = (graph) => {
  const nodes = graph.entities.map(e => ({
    id: e.id,
    label: e.name,
    color: getColorByType(e.type)
  }));
  
  const edges = graph.relations.map(r => ({
    from: r.sourceEntityId,
    to: r.targetEntityId,
    label: r.type
  }));
  
  const data = { nodes, edges };
  const options = {
    layout: { hierarchical: false },
    physics: { enabled: true }
  };
  
  new Network(graphContainer.value, data, options);
};
</script>
```

### 2. é›†æˆAIæå–

ä½¿ç”¨ OpenAI API è¿›è¡Œæ™ºèƒ½æå–ï¼š

```typescript
async function extractWithAI(content: string, toc: TocItem[]) {
  const prompt = `ä»ä»¥ä¸‹åœ°è´¨å­¦æ–‡æ¡£ä¸­æå–çŸ¥è¯†å›¾è°±ï¼š
ç›®å½•ï¼š${JSON.stringify(toc)}
å†…å®¹ï¼š${content.substring(0, 5000)}

è¯·æå–å®ä½“å’Œå…³ç³»ï¼Œè¿”å›JSONæ ¼å¼ã€‚`;
  
  const response = await openai.chat.completions.create({
    model: 'gpt-4',
    messages: [{ role: 'user', content: prompt }]
  });
  
  return JSON.parse(response.choices[0].message.content);
}
```

### 3. å…³ç³»æ¨ç†

å®ç°è·¯å¾„æŸ¥æ‰¾å’Œå…³ç³»æ¨ç†ï¼š

```typescript
// æŸ¥æ‰¾ä¸¤ä¸ªå®ä½“ä¹‹é—´çš„è·¯å¾„
async function findPath(sourceId: string, targetId: string, maxDepth: number = 5) {
  // ä½¿ç”¨å›¾éå†ç®—æ³•ï¼ˆBFS/DFSï¼‰
  // è¿”å›æœ€çŸ­è·¯å¾„
}
```

---

## âœ… æ£€æŸ¥æ¸…å•

- [ ] æ•°æ®åº“è¡¨åˆ›å»ºå®Œæˆ
- [ ] å‰ç«¯APIå°è£…å®Œæˆ
- [ ] åŸºç¡€å®ä½“æå–å®ç°
- [ ] ç®€å•å¯è§†åŒ–ç»„ä»¶å®Œæˆ
- [ ] é›†æˆåˆ°BookViewer
- [ ] åç«¯APIå®ç°
- [ ] æµ‹è¯•æå–åŠŸèƒ½
- [ ] æµ‹è¯•å¯è§†åŒ–æ˜¾ç¤º

---

## ğŸ¯ æ€»ç»“

è¿™ä¸ªå¿«é€Ÿå¼€å§‹æŒ‡å—æä¾›äº†ï¼š

1. **æœ€å°å¯è¡Œæ–¹æ¡ˆ**ï¼šä½¿ç”¨MySQLå­˜å‚¨ï¼Œç®€å•çš„æ–‡æœ¬æå–
2. **åŸºç¡€å¯è§†åŒ–**ï¼šæ–‡æœ¬åˆ—è¡¨å±•ç¤ºï¼ˆå¯å‡çº§ä¸ºå›¾å½¢ï¼‰
3. **å®Œæ•´ä»£ç ç¤ºä¾‹**ï¼šå‰ç«¯å’Œåç«¯å®ç°
4. **åç»­ä¼˜åŒ–æ–¹å‘**ï¼šå›¾å½¢å¯è§†åŒ–ã€AIæå–ã€å…³ç³»æ¨ç†

**å»ºè®®**ï¼šå…ˆå®ç°MVPï¼ŒéªŒè¯åŠŸèƒ½å¯è¡Œæ€§ï¼Œå†é€æ­¥ä¼˜åŒ–å’Œæ‰©å±•ã€‚

---

**éœ€è¦å¸®åŠ©ï¼Ÿ** æŸ¥çœ‹ã€ŠçŸ¥è¯†å›¾è°±é›†æˆæ–¹æ¡ˆ.mdã€‹è·å–è¯¦ç»†è®¾è®¡ã€‚


