# 📋 前后端配置说明

## 🎯 当前架构

### 数据流向

```
前端 (mineruApi.ts)
  ↓
Vite 代理 (vite.config.ts)
  ↓
后端 Spring Boot (MineruProxyController.java)
  ↓
MinerU API (https://mineru.net/api/v4)
```

### 详细说明

#### 1. 前端配置 (`mineruApi.ts`)

**作用：** 封装 API 调用，提供统一的接口

```typescript
// 开发环境
const MINERU_API_BASE = '/api/mineru'  // → Vite 代理 → 后端

// 生产环境
const MINERU_API_BASE = 'http://localhost:8080/api/mineru'  // → 直接调用后端
```

**前端只负责：**
- ✅ 封装 API 调用方法
- ✅ 处理请求参数
- ✅ 处理响应数据
- ✅ 错误处理

#### 2. Vite 代理配置 (`vite.config.ts`)

**作用：** 开发环境代理，避免 CORS 问题

```typescript
proxy: {
  '/api/mineru': {
    target: 'http://localhost:8080',  // 转发到后端
    changeOrigin: true
  }
}
```

#### 3. 后端配置 (`MineruProxyController.java`)

**作用：** 接收前端请求，转发到 MinerU API，处理业务逻辑

```java
@RestController
@RequestMapping("/api/mineru")
public class MineruProxyController {
    // 接收前端请求
    // 转发到 MinerU API
    // 处理文件上传、解析等业务逻辑
}
```

---

## ❓ 为什么需要后端？

### 方案对比

#### 方案 A：前端直接调用 MinerU API（❌ 不推荐）

```
前端 → MinerU API
```

**问题：**
1. ❌ **CORS 跨域问题**：浏览器会阻止跨域请求
2. ❌ **Token 安全**：Token 暴露在前端代码中，不安全
3. ❌ **无法处理文件上传**：需要先上传到 OSS，前端无法直接处理
4. ❌ **无法处理复杂业务逻辑**：如文件存储、状态管理等

#### 方案 B：通过后端代理（✅ 当前方案，推荐）

```
前端 → 后端 → MinerU API
```

**优势：**
1. ✅ **解决 CORS 问题**：后端作为代理，不受跨域限制
2. ✅ **Token 安全**：Token 保存在后端，不暴露给前端
3. ✅ **处理文件上传**：后端可以处理文件上传到 GitHub/OSS
4. ✅ **业务逻辑处理**：文件存储、状态管理、错误重试等
5. ✅ **网络代理支持**：后端可以配置代理访问 MinerU API

---

## 🔧 当前配置检查清单

### ✅ 前端配置（已完成）

- [x] `mineruApi.ts` - API 封装
- [x] `vite.config.ts` - Vite 代理配置
- [x] 环境变量配置

### ✅ 后端配置（需要确认）

- [x] `MineruProxyController.java` - 后端控制器
- [x] `application.yml` - MinerU API 配置
- [x] `RestTemplateConfig.java` - HTTP 客户端配置
- [x] `DocumentService.java` - 业务逻辑处理

---

## 🎯 后端必须配置的原因

### 1. 文件上传处理

**前端无法直接处理：**
- 需要先上传文件到 GitHub/OSS
- 获取文件 URL
- 然后调用 MinerU API

**后端处理：**
```java
// 1. 接收文件
@PostMapping("/upload")
public ResponseEntity<?> uploadFile(@RequestParam("file") MultipartFile file)

// 2. 上传到 GitHub
String fileUrl = uploadFileToGitHub(file);

// 3. 调用 MinerU API
createExtractTask(fileUrl);
```

### 2. Token 安全

**前端直接调用的问题：**
```typescript
// ❌ Token 暴露在前端代码中
const API_TOKEN = 'eyJ0eXBlIjoiSldUIi...';
```

**后端处理：**
```java
// ✅ Token 保存在后端配置文件中
@Value("${mineru.api.token}")
private String apiToken;
```

### 3. 网络代理支持

**后端可以配置代理：**
```yaml
proxy:
  enabled: true
  host: 127.0.0.1
  port: 7890
```

前端无法直接配置系统代理。

### 4. 错误处理和重试

**后端可以处理：**
- SSL 握手失败重试
- 网络错误重试
- 详细的错误诊断

---

## 📊 两种方案对比

| 特性 | 前端直接调用 | 后端代理（当前） |
|------|------------|----------------|
| CORS 问题 | ❌ 有跨域问题 | ✅ 无跨域问题 |
| Token 安全 | ❌ 暴露在前端 | ✅ 保存在后端 |
| 文件上传 | ❌ 无法处理 | ✅ 可以处理 |
| 网络代理 | ❌ 无法配置 | ✅ 可以配置 |
| 错误重试 | ❌ 有限 | ✅ 完整支持 |
| 业务逻辑 | ❌ 无法处理 | ✅ 可以处理 |

---

## 🚀 当前架构的优势

### 1. 安全性
- Token 不暴露给前端
- 可以添加权限验证
- 可以记录访问日志

### 2. 灵活性
- 可以切换不同的存储方案（GitHub/OSS/本地）
- 可以添加缓存、限流等功能
- 可以处理复杂的业务逻辑

### 3. 可维护性
- 前后端职责分离
- 后端可以独立升级
- 前端可以独立部署

---

## 💡 总结

### ✅ 需要后端配置

**原因：**
1. 前端只是封装了 API 调用，实际请求需要后端转发
2. 后端负责处理文件上传、解析等业务逻辑
3. 后端负责转发到 MinerU API（解决 CORS、Token 安全等问题）

### 📋 配置清单

**前端（已完成）：**
- ✅ `mineruApi.ts` - API 封装
- ✅ `vite.config.ts` - Vite 代理

**后端（需要确认）：**
- ✅ `MineruProxyController.java` - 控制器
- ✅ `application.yml` - 配置文件
- ✅ `RestTemplateConfig.java` - HTTP 客户端
- ✅ `DocumentService.java` - 业务逻辑

---

## 🔍 如果后端没有配置会怎样？

### 错误示例

**前端调用：**
```typescript
await createExtractTask({ url: '...' });
```

**结果：**
```
❌ 404 Not Found
或
❌ CORS error (如果直接调用 MinerU API)
```

**原因：**
- 前端请求 `/api/mineru/extract/task`
- Vite 代理转发到 `http://localhost:8080/api/mineru/extract/task`
- 如果后端没有对应的控制器，返回 404

---

## ✅ 结论

**是的，后端必须配置！**

前端配置只是封装了 API 调用，但实际的请求处理、文件上传、业务逻辑都需要后端来完成。

**当前架构是正确的：**
- 前端：负责 UI 和 API 调用封装
- 后端：负责业务逻辑和 MinerU API 转发

---

**最后更新**：2025-11-10

